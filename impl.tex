\section{Implementation} \label{sec:implementation}

We have implemented reactive computations as extensions to Orleans, an open-source distributed actor framework for .NET available on GitHub \cite{orleans}. The Orleans runtime already provides the needed distributed protocols for managing the creation, placement, discovery, recovery, and load-balancing of grains \cite{orleans-socc,orleanstr}. What we added is (a) extensions to the grain objects to store summaries, (b) interception points for grain calls, (b) modifications to the grain scheduler to distinguish between reactive and normal execution mode, and (c) a silo-wide cache manager. 

\subsection{Language and Framework}

So far, our exposition of the programming model and algorithm has avoided delving into particulars of the Orleans framework or of C\#. We now discuss some of these details.

\mypar{Disposal by \lstinline{using}} Until the programmer disposes the reactive computation object, the runtime incurs the cost of tracking summaries and propagating updates. To avoid leaking these computational resources accidentally,  programmers can use the C\# \lstinline|using| clause as shown in Fig. \ref{fig:impl} (\lref{using}). This guarantees that \lstinline|Dispose| is called automatically on the reactive computation when control leaves the block (\rref{ubl}), either normally or due to an exception (and it works correctly in combination with \textsf{await}). 

Disposing the reactive computation removes the summary associated with the reactive computation, and any local caches it depends on (unless those have other dependents). As described in  (\S\ref{sec:summaries}), this eventually guarantees that all summaries and caches that have no observers are removed. It can take some time because summaries are not removed until 90 seconds have passed since the last subscription by a cache (\S\ref{sec:ft}). 

\mypar{Asynchronous I/O} ResultTrackers are well suited for situations where updating the display requires I/O, such as when communicating with a remotely connected client device:   (1) result trackers may skip intermediate versions: only the latest result matters, and (2) result trackers return a task that can be efficiently awaited without blocking the thread.  (using C\# language support for async/await \cite{Bierman2012}). 

It is possible to use multiple result trackers for the same reactive computation, and each one can consume results at its own speed (for example, over different websockets).

\mypar{Exception Handling}
As can be seen from Fig.~\ref{fig:impl}, whenever an exception occurs somewhere down the reactive computation, we don't simply stop the computation and deconstruct the dependency graph. Instead we assume the exception just occurred due to some current state of the grains, but following states might produce results again. The exception can be caught (1) either somewhere upstream in the reactive computation itself, or (2) on the \lstinline|NextResult()| call of a tracker if it wasn't caught. This provides a uniform way of handling both faults (timeout exceptions) (Fig.~\ref{fig:impl} line 9) and computational exceptions (Fig.~\ref{fig:impl} line 13).


% This Figure can easily be removed when the page limit is reached %%
\begin{figure}
\begin{lstlisting}
using(var rc = CreateReactiveComputation( %\label{l:using}%
									() => Grain[myuserid].GetTimeline())) 
{%\label{b:ubl}%
	using(var resulttracker = rc.GetResultTracker()) 
	{
		while (interested) {
			try {
				var result = await resulttracker.NextResult();
				display(result);
			} catch(TimeoutException) { %\label{b:eh}%
				display("server is not responding, retrying...");
			} catch(DivisionByZeroException) {
				display("can't divide by zero");			
			}%\label{e:eh}%
		}
	}
}%\label{e:ubl}%
\end{lstlisting}
\caption{Proposed solution, including the \texttt{using} constructs that make sure the graph is garbage collected when no longer required.}\label{fig:impl}
\end{figure}
\subsection{Effects, Dependencies, and Determinism}

\mypar{Detecting Changes} The propagation algorithm described in \S~\ref{sec:cp} requires that we detect whenever the state of a grain changes. Unfortunately, in Orleans, we cannot easily detect whether an operation has side effects, because grains are C\# objects, and the use of heap and libraries obfuscates the presence of side effects. Therefore, we overapproximate and conservatively assume that \emph{all} operations change the grain's state. This is not as expensive as it may seem at first, because if the grain state has not changed, or changed in ways that are irrelevant, re-execution of the summary produces the same result, and propagation stops. 

Programmers can annotate an operation with a \lstinline|[ReadOnly]| attribute to avoid the re-execution overhead; also, we assume that any operation called as part of a reactive computation does not change the grain state, and thus avoid summary re-execution in that case.

\mypar{To execute or not to execute}
Our algorithm changes the way grain operations are executed, which can surprise programmers.  Any method that is called from within a reactive context is now prone to being re-executed without the programmer explicitly performing the call. Conversely, calling any such method may skip the execution entirely and instead return a cached result. In theory, this is fine as long the method does not modify any state, and if it does not have an external dependency that is invisible to our staleness detection (e.g. read a clock or do arbitrary I/O). 

These conditions are usually satisfied as reactive computations are meant to be used for some kind of \emph{query} over the distributed state. However, currently, we do not enforce them. For a different host language, one can imagine a type/effect system to this end. However, note also that a naive rigid enforcement is not advisable, because we want to allow harmless side effects (such as writing a timestamped message to a log). 

\mypar{Determinism} 
We do \emph{not} require that grain operations are deterministic. For example, it is o.k. for an operation to call two other grains concurrently, and return the first of the two results returned. By definition, a cached value is considered stale only if a re-execution \emph{must} return a different result, not if it \emph{may} return a different result.
 
 
\hidden
{
\subsection{Runtime Implementation}

Under the hood, the runtime must provide the needed distributed protocols for managing the creation, placement, discovery, recovery, and load-balancing of actors. By design, the application layer is largely unaware of how these details. Nevertheless, we briefly describe the mechanisms used by the Orleans system here. 

\mypar{Grain Directory} Grains can be active (there exists an instance of it on some machine) or inactive (otherwise). The runtime maintains a distributed directory (based on the consistent hashing algorithm)  for tracking active grains. When an inactive grain is accessed, the runtime automatically activates it, and places it on a randomly selected server. If a grain is not accessed for a prolonged (configurable) time, it is deactivated and removed from the grain directory. 

\mypar{Silo Failures} Under the hood, the runtime tracks all participating servers, called \emph{silos}, using a membership protocol. The set of members can change when administrators choose to increase or decrease the number of servers, or when servers fail, which is detected automatically.  For \emph{volatile} grains, the grain state is lost on failure. For \emph{persistent} grains, the grain state is saved to persistent storage after each change, and loaded from persistent storage when activated. 
 

--- The actual C\# code is similar, but contains more detail and uses language features that are not highly relevant in this context, albeit interesting in their own right (e.g. LINQ expressions, cooperative concurrency with async-await).

--- ResultTrackers have some interesting properties that make them well suited for situations where updating the display requires I/O, such as when communicating with a remotely connected client device:   (1) result trackers may skip intermediate versions: only the latest result matters, and (2) result trackers return a task that can be efficiently awaited without blocking the thread (using C\# language support for async/await \cite{Bierman2012}).  Also, it is possible to use multiple result trackers for the same reactive computation, and each one can consume results at its own speed.

--- reactive computations available on silo or client
}

