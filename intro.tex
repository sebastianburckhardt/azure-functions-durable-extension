\section{Introduction}

Applications that run on client devices and cloud services are ubiquitous today. Since the early days of the internet, such applications have evolved from simple data-delivery engines to distributed reactive applications that let users share the experience and interact socially. Whether it is about games, collaborative editing, or online conversations: connecting users in real-time via a scalable and fault-tolerant service remains a significant challenge.

Research on \emph{reactive programming} has proposed many interesting solutions, and the community has been experimenting with many programming languages, language extensions, and frameworks. Simply speaking, a reactive programming model combines (1) a convenient way to express a view of some state or event source, and (2) a corresponding efficient mechanism that can update the view in response to state updates or events. It is a rich design space including many different philosophies and implementations. 

For example, in \emph{functional-reactive programming (FRP)}, we express views as signals that depend on event streams, and define them using a vocabulary of functional operators. Another option, which we shall call \emph{model-view computation}, is to define views as the result of a computation that depends on the model state. In either case, clever implementation tricks (operator compilation, virtual DOMs, recursive tree structures, self-adjusting computation) can help to achieve efficient change propagation. 

An important difference is that with FRP, all intermediate values matter (streams must not lose events), while for model-view computation, only the latest state of the model is relevant for computing the view. This distinction becomes relevant when considering fault tolerance.

Much research has focused on reactive programming for graphical user interfaces \cite{} on the client. But often, the state or the events to be observed are located not in the client, but the service. Providing a reactive programming model for services is however much harder than for a single machine. Performance is more elusive because of the high communication latency between machines. Moreover, a good service provides \emph{elastic scalability} (runs on a cluster that can be grown or shrunk at runtime),  \emph{fault tolerance} (automatically handles individual server failures) and \emph{compute-storage separation} (persists application data in a separate cloud storage system).

\emph{Actors} have emerged as a viable model for developing such services, because they can be easily distributed over a cluster. In particular, \emph{virtual actor} runtimes provide the necessary protocols for compute-storage separation, load balancing, and fault detection. But how can we support reactive programming on such systems?
 
A common ad-hoc solution is to employ some sort of \emph{observer pattern}. The programmer takes full responsibility for tracking dependencies and propagating changes between actors. But even for non-distributed programs, observer patterns can lead to complex and error-prone code \cite{}; this only gets worse when we have to tolerate failures and provide persistence. 
%Clearly, more support from the language or runtime is desirable.

Another common approach is to add support for \emph{streams} \cite{}. However, combining actors and streams is confusing, as the FRP paradigm (state is represented by event streams) conflicts with the actor paradigm (state is encapsulated by actors). Also, fault tolerance and persistence are difficult with streams. Naive solutions that persist every event may not perform satisfactorily. 

In this work, we propose an alternative approach to distributed reactive programming that stays entirely within the actor paradigm, using the model-view computation approach instead of FRP. This allows us to provide \emph{automatic reactivity} as a feature of the actor runtime. 

Concretely, any client of the service can issue a \emph{reactive computation} that computes some result that depends on one or more actors of the service. But, as in self-adjusting computation \cite{}, this result is computed not just once, but \emph{continuously}: the latest result is pushed to the client whenever it changes. 

Notably, \emph{the service code remains exactly the same} - all the programmer has to do is to use a reactive computation on the client.  All the magic happens in the runtime: it executes the computation in a special mode that intercepts all actor calls, including nested calls, and constructs a distributed dependency graph. Whenever the state of any actor involved in the computation changes, the change is automatically  propagated. This happens for as long as the reactive computation remains active. 
 

%Also, note that this computation is not restricted to a predefined vocabulary of operators, but can execute any code of the host language (imperative or functional). It does not require static analysis, but can call any number of dynamically determined actors, sequentially or in parallel. 

We have implemented

eventual consistency
 
 We make the following contributions:
 
 
 \begin{enumerate}
 \item We demonstrate how to add support for reactivity 
 \item  An algorithm that
 \item An evaluation
 \end{enumerate}
 
 
     
   
 
\hidden
{
oncern.s between consistency and performance, and question of trading  choice to make highly depends on the circumstancesand may choose use explicit timeSynchronous vs. asynchronous, glitches, 
 
This structure can lead to specialized solutions (for example, the database community has known for decades how to solve the view-update problem for relational data). helps to implement efficient algorithms  to the view-update problem. Recursion is common, where views become subjects of other views: for example, signals in FRP can be defined in terms of other signals. Semantics can differ in how they treat 


use relations, may be monolithic, or graphs of objects. For example, database Facebook react has 
relationship, and how changes are propagated by the runtime. Prior approaches to reactive programming fall into two camps: explicit (the programmer expresses dependencies) and implicit (program expresses the viewdependencies are detected automatically, either at compile-time or at runtime).
Examples of explicit: makefiles, Rx, FRP. Examples of implicit: self-adjusting computation, Facebook React.

Philosophical: Model-View separation, Event Streams

  is has focused on specifying dataflow explicity. However, there are some 
}

