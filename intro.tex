\section{Introduction}

Applications that run on client devices and cloud services are ubiquitous today. Since the early days of the internet, such applications have evolved from simple page-delivery engines to distributed reactive applications that let users share the experience and interact socially. Whether it is about games, collaborative editing, or online conversations: connecting users in real-time via a scalable and fault-tolerant service remains a significant and exciting challenge.

\mypar{Reactive Programming} Research on reactive programming has proposed many interesting solutions, and the community has been experimenting with many programming languages, language extensions, and frameworks. Simply speaking, a reactive programming model combines (1) a convenient way to express a view of some state or event source, and (2) a corresponding efficient mechanism that can update the view in response to state updates or events. It is a rich design space including many different philosophies and implementations. 

For example, in \emph{functional-reactive programming (FRP)}, we express views as signals that depend on event streams, and define them using a vocabulary of functional operators or combinators \cite{frp-firstprinciples,frp-animation,frp-frtime,elm,afp}. Another approach, which we call \emph{model-view computation}, is to define views as the result of a computation (functional or imperative) that depends on the model state \cite{alive,react}. In either case, propagating small changes selectively and efficiently is key. This can be achieved not only using FRP-style language support, but (alternatively or additionally) by runtime algorithms (such as virtual DOMs \cite{react,alive}, one-way dataflow constraints \cite{camil}, or self-adjusting computation \cite{acar-ahmed-blume-POPL08}) that can isolate which parts of a computation need to be updated in response to a change.

An important difference is that with FRP, all intermediate values matter (streams must not lose events), while for model-view computation, only the latest state of the model is relevant for computing the view. This distinction gains relevance when considering fault tolerance.

\mypar{Actor-Based Cloud Services} Much research has focused on reactive programming for graphical user interfaces \cite{elm,flapjax,alive} on the client. But often, the observed state or events are located not on the client, but in the service. Providing a reactive programming model for services is much harder than for a single machine. Performance is more elusive because of the high communication latency between machines. Moreover, a good service provides \emph{elastic scalability} (runs on a cluster that can be grown or shrunk at runtime),  \emph{fault tolerance} (automatically handles individual server failures) and \emph{compute-storage separation} (persists application data in a separate cloud storage system), all of which are not guaranteed by the current distributed reactive models.

\emph{Actors} have emerged as a viable model for developing such services, because they can be distributed over a cluster \cite{erlang,akka,orleans}. In particular, \emph{virtual actor} runtimes \cite{orleanstr,orleans,sfactors,orbit} provide the necessary distributed protocols for persistence, load balancing, and fault detection. But how can we support reactive programming on virtual actor systems?
 
A common ad-hoc solution is to employ some sort of \emph{observer pattern}. The programmer takes full responsibility for tracking dependencies and propagating changes between actors. But even for non-distributed programs, observer patterns can lead to complex and error-prone code \cite{sobserver}; this only gets worse when we have to tolerate failures and provide persistence. 
%Clearly, more support from the language or runtime is desirable.

Another common approach is to add support for \emph{streams} \cite{orleans,reactors-io}. However, combining actors and streams can be confusing, as the FRP paradigm (state is an event stream) is at odds with the actor paradigm (state is encapsulated by asynchronously communicating actors). It is difficult to keep programs that combine actors and streams both fault tolerant and performant --- persisting every event in a stream is costly. Similarly, combining actors with a publish-subscribe mechanism \cite{patrick} can ameliorate some of the drawbacks of observers, but does complicate fault tolerance and persistence.

\mypar{Reactive Computations} In this work, we propose a novel approach to distributed reactive programming that does not replace the actor paradigm, but extends it with a new feature called \emph{reactive computations}. Any client of the service can start such a reactive computation, which computes some result that depends on one or more actors of the service. But, as in self-adjusting computation \cite{Acar:SelfAdjustingOverview}, this result is computed not just once, but \emph{continuously}: the latest result is pushed to the client whenever it changes. 

Notably, the service code remains exactly the same ---  all the programmer has to do is to use a reactive computation on the client.  The reactive magic is not in the program, but in the runtime: it executes the computation in a special mode that intercepts all actor calls, including nested calls, and constructs a distributed dependency graph. Whenever the state of any actor involved in the computation changes, the change is automatically propagated, i.e. pushed along the edges of the dependency graph. This happens for as long as the reactive computation remains active. 

%Also, note that this computation is not restricted to a predefined vocabulary of operators, but can execute any code of the host language (imperative or functional). It does not require static analysis, but can call any number of dynamically determined actors, sequentially or in parallel. 

\mypar{Contributions} We make the following contributions:
\begin{enumerate}
\item We propose a new programming model for reactive elastic services, which extends the virtual actor model (\S\ref{sec:virtualactors}) with runtime support for reactive computations (\S\ref{sec:formulation}). 
\item We present a new fault-tolerant distributed reactive caching algorithm (\S\ref{sec:algorithm}), and implement it as an extension of the Orleans virtual actor runtime (\S\ref{sec:implementation}).
\item We provide a performance evaluation (\S\ref{sec:evaluation}) that demonstrates that the latency and throughput of our automatic change propagation compares favorably with alternative solutions, such as manual change propagation and polling.
\end{enumerate}    
   
\hidden
{
oncern.s between consistency and performance, and question of trading  choice to make highly depends on the circumstancesand may choose use explicit timeSynchronous vs. asynchronous, glitches, 
 
This structure can lead to specialized solutions (for example, the database community has known for decades how to solve the view-update problem for relational data). helps to implement efficient algorithms  to the view-update problem. Recursion is common, where views become subjects of other views: for example, signals in FRP can be defined in terms of other signals. Semantics can differ in how they treat 


use relations, may be monolithic, or graphs of objects. For example, database Facebook react has 
relationship, and how changes are propagated by the runtime. Prior approaches to reactive programming fall into two camps: explicit (the programmer expresses dependencies) and implicit (program expresses the viewdependencies are detected automatically, either at compile-time or at runtime).
Examples of explicit: makefiles, Rx, FRP. Examples of implicit: self-adjusting computation, Facebook React.

Philosophical: Model-View separation, Event Streams

  is has focused on specifying dataflow explicity. However, there are some 
}

