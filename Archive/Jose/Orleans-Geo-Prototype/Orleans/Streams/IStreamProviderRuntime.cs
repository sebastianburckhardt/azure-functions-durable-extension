#if !DISABLE_STREAMS

using System;
using System.Collections.Generic;
using System.Threading.Tasks;
using Orleans.Providers;

namespace Orleans.Streams
{
    /// <summary>
    /// Provider-facing interface for manager of streaming providers
    /// </summary>
    internal interface IStreamProviderRuntime : IProviderRuntime
    {
        /// <summary>
        /// Retrieves the opaque identity of currently executing grain or client object. 
        /// Just for logging purposes.
        /// </summary>
        /// <param name="handler"></param>
        string ExecutingEntityIdentity();

        SiloAddress ExecutingSiloAddress { get; }

        void RegisterSystemTarget(ISystemTarget target);

        /// <summary>
        /// Register a timer to send regular callbacks to this grain.
        /// This timer will keep the current grain from being deactivated.
        /// </summary>
        /// <param name="callback"></param>
        /// <param name="state"></param>
        /// <param name="dueTime"></param>
        /// <param name="period"></param>
        /// <returns></returns>
        IDisposable RegisterTimer(Func<object, Task> asyncCallback, object state, TimeSpan dueTime, TimeSpan period);

        /// <summary>
        /// Binds an extension to an addressable object, if not already done.
        /// </summary>
        /// <typeparam name="TExtension">The type of the extension (e.g. StreamConsumerExtension).</typeparam>
        /// <param name="newExtensionFunc">A factory function that constructs a new extension object.</param>
        /// <returns>A tuple, containing first the extension and second an addressable reference to the extension's interface.</returns>
        Task<Tuple<TExtension, TExtensionInterface>> BindExtension<TExtension, TExtensionInterface>(Func<TExtension> newExtensionFunc)
            where TExtension : IGrainExtension
            where TExtensionInterface : IGrainExtension;

        /// <summary>
        /// A Pub Sub runtime interface.
        /// </summary>
        /// <returns></returns>
        IStreamPubSub PubSub(StreamPubSubType pubSubType);

        /// <summary>
        /// A consistent ring interface.
        /// </summary>
        /// <param name="pubSubType"></param>
        /// <returns></returns>
        IConsistentRingProviderForGrains ConsistentRingProvider { get; }

        /// <summary>
        /// Return true if this runtime executes inside silo, false otherwise (on the client).
        /// </summary>
        /// <param name="pubSubType"></param>
        /// <returns></returns>
        bool InSilo { get; }

        /// <summary>
        /// Invoke the given async function from within a valid Orleans scheduler context.
        /// </summary>
        /// <param name="asyncFunc"></param>
        Task InvokeWithinSchedulingContextAsync(Func<Task> asyncFunc, object context);

        object GetCurrentSchedulingContext();
    }

    internal enum StreamPubSubType
    {
        GRAINBASED
    }

    [Serializable]
    public struct PubSubSubscriptionState : IEquatable<PubSubSubscriptionState>
    {
        // Those fields have to be public non-readonly for JSonSerialization to work!
        public StreamId Stream;
        public IStreamConsumerExtension Consumer;
        public StreamSequenceToken StreamSequenceToken;

        internal PubSubSubscriptionState(StreamId streamId, IStreamConsumerExtension streamConsumer, StreamSequenceToken token)
        {
            Stream = streamId;
            Consumer = streamConsumer;
            StreamSequenceToken = token;
        }

        public override bool Equals(object obj)
        {
            if (ReferenceEquals(null, obj)) return false;
            // Note: Can't use the 'as' operator on PubSubSubscriptionState because it is a struct.
            return obj is PubSubSubscriptionState && Equals((PubSubSubscriptionState)obj);
        }
        public bool Equals(PubSubSubscriptionState other)
        {
            // Note: PubSubSubscriptionState is a struct, so 'other' can never be null.
            return Equals(other.Stream, other.Consumer);
    }
        public bool Equals(StreamId streamId, IStreamConsumerExtension streamConsumer)
        {
            if (ReferenceEquals(null, this.Stream)) return false;
            if (ReferenceEquals(null, this.Consumer)) return false;
            return Stream.Equals(streamId) && Consumer.Equals(streamConsumer);
        }

        public override int GetHashCode()
        {
            // This code was auto-generated by ReSharper
            unchecked
            {
                return ((Stream != null ? Stream.GetHashCode() : 0) * 397) ^ (Consumer != null ? Consumer.GetHashCode() : 0);
            }
        }

        public static bool operator ==(PubSubSubscriptionState left, PubSubSubscriptionState right)
        {
            return left.Equals(right);
        }

        public static bool operator !=(PubSubSubscriptionState left, PubSubSubscriptionState right)
        {
            return !left.Equals(right);
        }

        public override string ToString()
        {
            return string.Format("PubSubSubscriptionState:StreamId={0},Consumer={1},SequenceToken={2}.",
                Stream, Consumer, StreamSequenceToken);
        }
    }

    [Serializable]
    public struct PubSubPublisherState : IEquatable<PubSubPublisherState>
    {
        // Those fields have to be public non-readonly for JSonSerialization to work!
        public StreamId Stream;
        public IStreamProducerExtension Producer;

        internal PubSubPublisherState(StreamId streamId, IStreamProducerExtension streamProducer)
        {
            Stream = streamId;
            Producer = streamProducer;
        }

        #region IEquatable<PubSubPublisherState> methods auto-ganerated by ReSharper
        public override bool Equals(object obj)
        {
            if (ReferenceEquals(null, obj)) return false;
            // Note: Can't use the 'as' operator on PubSubPublisherState because it is a struct.
            return obj is PubSubPublisherState && Equals((PubSubPublisherState)obj);
        }
        public bool Equals(PubSubPublisherState other)
        {
            // Note: PubSubPublisherState is a struct, so 'other' can never be null.
            return Equals(other.Stream, other.Producer);
        }
        public bool Equals(StreamId streamId, IStreamProducerExtension streamProducer)
        {
            if (ReferenceEquals(null, this.Stream)) return false;
            if (ReferenceEquals(null, this.Producer)) return false;
            return Stream.Equals(streamId) && Producer.Equals(streamProducer);
        }

        public static bool operator ==(PubSubPublisherState left, PubSubPublisherState right)
        {
            return left.Equals(right);
        }
        public static bool operator !=(PubSubPublisherState left, PubSubPublisherState right)
        {
            return !left.Equals(right);
        }
        public override int GetHashCode()
        {
            // This code was auto-generated by ReSharper
            unchecked
            {
                return ((Stream != null ? Stream.GetHashCode() : 0) * 397) ^ (Producer != null ? Producer.GetHashCode() : 0);
            }
        }
        #endregion

        public override string ToString()
        {
            return string.Format("PubSubPublisherState:StreamId={0},Producer={1}.", Stream, Producer);
        }
    }

    internal interface IStreamPubSub // Compare with: IPubSubRendezvousGrain
    {
        Task<ISet<PubSubSubscriptionState>> RegisterProducer(StreamId streamId, IStreamProducerExtension streamProducer);
        
        Task UnregisterProducer(StreamId streamId, IStreamProducerExtension streamProducer);

        Task RegisterConsumer(StreamId streamId, IStreamConsumerExtension streamConsumer, StreamSequenceToken token);

        Task UnregisterConsumer(StreamId streamId, IStreamConsumerExtension streamConsumer);

        Task<int> ProducerCount(StreamId streamId);

        Task<int> ConsumerCount(StreamId streamId);
    }
}

#endif