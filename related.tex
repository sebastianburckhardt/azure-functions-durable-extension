\section{Related Work}

\noindent{to do. I will focus on this section on Monday.}

\hidden
{
\subsection{Expressing Views.} Often, views can observe other views, creating a directed acyclic graph of dependencies. How to express such dependency graphs using recursive operators is a key question in the area of dataflow languages, functional reactive programming, and object-oriented frameworks such as Rx. In relational database systems, views are expressed by relational queries (which allows changes to be propagated incrementally). in Facebook's react.js, the application state is observed by a tree-structured virtual DOM, which is in turn observed by the browser's DOM. And in relational database systems, views are expressed by relational queries (which allows changes to be propagated incrementally). 

We list a few common variations: (1) changes may be pushed or pulled, (2) propagation may happen in response to a periodic timer or in response to other changes, and (3) changes may be propagated as deltas (the difference between the previous observed state and the new observed state), or as summaries (the entire observed state).

  relative change), or as summaries that contain the complete observed information  (which must be interpreted relative to the previous stateChange propagation can take many forms: changes may be pulled or pushed, and from the view, or pushed to the view. propagation may happen he view may pull changes, or the obseperiodically (called \emph{polling}) In the following, we call an observer a \emph{view}, and we define the \emph{state} of a view as the set of updates that has been propagated to it. 




Change propagation is semantically subtle. In sychronous models, time is explicit. Asynchronous models may make strong consistency guarantees based on some form of version tracking, or may have weaker consistency guarantees. For example, a so-called glitch means that an observer sees two observables A, B that have inconsistent state, meaning that the set of updates propagated to A is different from the set of updates propagated to B. are ey may exhibit glitches, where a view see. Clearly, how to best balance consistency and performance is highly dependent on the architecture and workload. 
}

\cite{burckhardt-leijen-yi-sadowski-ball-OOPSLA11}
\cite{camil}


\cite{alive}
\cite{react}

\cite{elm} language for gui construction

\cite{statelines} inverse problem

% These are just paragraphs of information about certain topics, still needs to be put in a nice text if they are used %



General purpose FRP models \cite{reactivesurvey} require you to write down your program in terms of signals and behaviours, i.e. explicitly writing down the dependency graph. Furthermore, while still a lot of research is being conducted to efficiently perform glitch-free propagation cycles on a single node, lately some initial research is being performed to do this in a distributed setting \cite{elm}\cite{drescala}. Even though we believe future research might solve this, right now it is tremendously difficult to create a distributed propagation algorithm that can handle dynamic dependency graphs and doesn't require a central coordinator. The presented model in this paper is very different in that sense, because it allows executions that observe a glitch. Yet, it does guarantee that it will eventually perform a glitch-free execution. As a result, this algorithm naturally lends itself more towards large-scale, fault-tolerant systems, by sacrificing some consistency guarantees.


Big data processing/analytics models: (1) batch processing (Spark, Hadoop) \cite{mapreduce} and (2) stream processing (Apache Flink \& Storm). Can be seen as a  distributed FRP model, because it uses functional operators over sets of distributed data. Batch processing assumes the data doesn't change and stream processing is able to handle continuously changing data. They have the same drawback as any FRP, in that they require special purpose types and functions.

